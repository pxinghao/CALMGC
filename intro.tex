%!TEX root = bloom_logical.tex

\section{Introduction}
\label{sec:intro}


It is worth highlighting the similarities and differences of our approach from that of \cite{marczak2012confluence}.
In \cite{marczak2012confluence}, the syntax of the language was restricted such that sets are always growing\footnote{In Dedalus$^+$ formalism, all sets are `temporally inflationary'.}, and can therefore can be shown to be confluent.
However, this is a sufficient but not necessary restriction on the language, and there are confluent programs (or programs that are confluent on particular important output sets) that are not expressible in the fully-confluent sublanguage of \cite{marczak2012confluence}.
Any confluent garbage collection program would shrink sets and is thus not expressible in Dedalus$^+$.
In contrast, we restrict the semantics of the garbage collection rules to ensure that derivations of tuples are not affected.
Our program provides weaker guarantees of confluence, but is nevertheless confluent in the important output sets.
One disadvantage of our approach is that confluence cannot be statically validated (as is possible with Dedalus$^+$);
instead, the programmer provide a certificate that the semantics of the garbage collection rules are valid before a static analysis can determine confluence of our program.
We provide these guarantees for some simple examples in this paper.


The rest of this paper is organized as follows.
We begin with some preliminaries and notations in Section \ref{sec:prelims}.
An overview of our approach is presented in Section \ref{sec:approach}.
Section \ref{sec:rewrites} then describes the rewrite of an ELE program expressed in Edelweiss into a logical garbage collection program and an instantiated garbage collection program.
We then analyze the logical program in Section \ref{sec:logical} and the instantiated program in Section \ref{sec:instantiated}.
For clarity of exposition, we defer the discussion of garbage collection for asynchronous rules (which send messages between nodes) to Section \ref{sec:async_gc}.
Finally, we conclude in Section \ref{sec:conclude}.
